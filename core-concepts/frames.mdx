---
title: Frames
description: 'Understanding frames - the fundamental unit of data flowing through Pipecat pipelines.'
---

## What are Frames?

Frames are the fundamental unit of data in Pipecat. Like packages on a conveyor belt, each frame contains a specific type of data and metadata about how it should be handled. Every piece of information - from audio samples to LLM responses - travels through your application as a frame.

## Frame Types

### System Frames

System frames carry control signals and can bypass normal processing rules. They're used for critical operations and system control:

```python
# Examples of system frames
CancelFrame()              # Stop processing (e.g., Ctrl-C)
StartInterruptionFrame()   # User started speaking
EndInterruptionFrame()     # User stopped speaking
```

### Control Frames

Control frames manage the flow of processing:

```python
# Examples of control frames
TTSStartFrame()           # TTS service starting output
LLMStartResponseFrame()   # LLM beginning to respond
EndFrame()               # Pipeline ending
```

### Data Frames

Data frames carry the actual content through your application:

```python
# Examples of data frames
from pipecat.frames import (
    AudioFrame,
    TextFrame,
    ImageFrame,
    LLMMessagesFrame
)

# Audio data (e.g., from microphone)
audio_frame = AudioFrame(audio_data, sample_rate=16000)

# Transcribed speech
text_frame = TextFrame("Hello, how can I help you?")

# Conversation context
llm_frame = LLMMessagesFrame([
    {"role": "user", "content": "What's the weather?"},
    {"role": "assistant", "content": "I can help with that."}
])
```

### Application Frames

Custom frames for your specific application needs:

```python
class CustomStateFrame(Frame):
    def __init__(self, state_data):
        super().__init__()
        self.state_data = state_data
```

## Frame Properties

Every frame includes essential metadata:

```python
class ExampleFrame(Frame):
    def __init__(self, data):
        super().__init__(
            type="example/data",        # Frame type identifier
            timestamp=time.time(),      # When the frame was created
            id=generate_unique_id(),    # Unique frame identifier
            metadata={                  # Additional information
                "source": "example",
                "processor_chain": ["p1", "p2"]
            }
        )
        self.data = data
```

### Core Properties

- **type**: Identifies the frame's content type (e.g., `image/raw`, `text/plain`)
- **timestamp**: When the frame was created
- **id**: Unique identifier for tracking
- **processor_chain**: List of processors that handled the frame
- **metadata**: Additional contextual information

## Frame Flow

Frames move through your pipeline in a specific way:

```python
# Example pipeline showing frame flow
pipeline = Pipeline([
    transport.input(),     # Creates AudioFrames
    transcriber,          # AudioFrames -> TextFrames
    llm_processor,        # TextFrames -> LLMResponseFrames
    tts_service,         # LLMResponseFrames -> AudioFrames
    transport.output()    # Handles AudioFrames
])
```

1. Each processor receives frames
2. Processes frames it's interested in
3. Generates new frames as needed
4. Passes through frames it doesn't handle

## Frame Ordering

Frames maintain their order through the pipeline (except for system frames):

```python
# Example showing frame ordering
async def process_frame(self, frame: Frame):
    if isinstance(frame, TextFrame):
        # Process frames in order received
        response = await self.generate_response(frame.text)
        # Push frames in same order
        await self.push_frame(ResponseFrame(response))
```

## Best Practices

### Type Checking

Always check frame types before processing:

```python
async def process_frame(self, frame: Frame):
    if not isinstance(frame, AudioFrame):
        return
    # Process audio frame
```

### Metadata Usage

Include relevant metadata for debugging and tracking:

```python
await self.push_frame(TextFrame(
    text="Hello!",
    metadata={
        "confidence": 0.95,
        "source": "transcription"
    }
))
```

### Frame Creation

Create new frames instead of modifying existing ones:

```python
# Good - create new frame
new_frame = TextFrame(processed_text)

# Bad - modify existing frame
frame.text = processed_text
```

## Next Steps

Now that you understand frames, learn how they're processed in:

- [Frame Processors](/core-concepts/processors)
- [Pipelines](/core-concepts/pipelines)
